{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web Call Center for Laravel Overview This project aims to provide a web call center service where organizations and institutes that provide customer service and support can use, it's a WebRTC based project using Agora IO service to enable customers around the world contact your organization's customer support agents through web, it also supports receiving calls from Android and iOS applications that have Agora Mobile SDK integrated. This project can be used on its own within a bare Laravel application , or it can be integrated within existing Laravel applications , please refer to the \"Getting Started\" page that corresponds with your use case. IMPORTANT NOTICE This project is still in early stages of development thus, it only provides basic features as of now, the list of available features is listed in the next section. Features Agents dashboard for customer support personnel to receive incoming calls. Customers prototype dashboard that enables them to make calls to one of the enlisted organizations. An organization can be any establishment that provides some kind of service or products to public e.g. hospitals, restaurants, agencies, or any other sort of business. Automatic management of incoming calls to a particular organization. On heavily incoming calls, the project will distribute them simply on all available agents i.e. an incoming call will always be assigned to the least occupied agent who's currently online within the organization requested by the calling customer. The dashboards included are customizable within any Laravel application whether used alone as a sole project, or integrated to an existing project. Integration to existing Laravel project can use your own existing models - database tables - that represent the required entities for the project to function. You'll need to have models that represent organizations, customer support agents and finally, customers. Or you can use the included models and database tables which are already defined within the project. Attribution The idea of this project wouldn't have come to life without the following amazing technologies and the great people behind their development: Laravel Laravel Websockets WebRTC by Google Agora IO Bootstrap Vue And the marvelous software that generated this documentation. MkDocs MkDocs Material","title":"Web Call Center for Laravel"},{"location":"#web-call-center-for-laravel","text":"","title":"Web Call Center for Laravel"},{"location":"#overview","text":"This project aims to provide a web call center service where organizations and institutes that provide customer service and support can use, it's a WebRTC based project using Agora IO service to enable customers around the world contact your organization's customer support agents through web, it also supports receiving calls from Android and iOS applications that have Agora Mobile SDK integrated. This project can be used on its own within a bare Laravel application , or it can be integrated within existing Laravel applications , please refer to the \"Getting Started\" page that corresponds with your use case. IMPORTANT NOTICE This project is still in early stages of development thus, it only provides basic features as of now, the list of available features is listed in the next section.","title":"Overview"},{"location":"#features","text":"Agents dashboard for customer support personnel to receive incoming calls. Customers prototype dashboard that enables them to make calls to one of the enlisted organizations. An organization can be any establishment that provides some kind of service or products to public e.g. hospitals, restaurants, agencies, or any other sort of business. Automatic management of incoming calls to a particular organization. On heavily incoming calls, the project will distribute them simply on all available agents i.e. an incoming call will always be assigned to the least occupied agent who's currently online within the organization requested by the calling customer. The dashboards included are customizable within any Laravel application whether used alone as a sole project, or integrated to an existing project. Integration to existing Laravel project can use your own existing models - database tables - that represent the required entities for the project to function. You'll need to have models that represent organizations, customer support agents and finally, customers. Or you can use the included models and database tables which are already defined within the project.","title":"Features"},{"location":"#attribution","text":"The idea of this project wouldn't have come to life without the following amazing technologies and the great people behind their development: Laravel Laravel Websockets WebRTC by Google Agora IO Bootstrap Vue And the marvelous software that generated this documentation. MkDocs MkDocs Material","title":"Attribution"},{"location":"getting-started/bare-project/","text":"Bare Project Overview This guide will lead you to install the project as a stand-alone web application, most of the configuration settings will be kept intact and, default web views will be used directly. 1. Creating a Laravel project. First you'll need a fresh installation of the Laravel framework by going through its official documentation here , or you can follow the following summarized steps. 1.a. Create project In terminal at your web root please run the following command: $ composer create-project laravel/laravel <your_project_name> --prefer-dist $ cd <your_project_name> Replacing <your_project_name> with project name of your preference. 1.b. Setting up the Database. Then you'll have to create the database for the project so, you'll need to login to your database server in terminal. $ mysql -u <username> -p Replacing <username> with your database server's username then, enter the password when prompted and, finally in the open mysql terminal you may write: create database <database_name>; exit; Replacing <database_name> with the name you'd like to give to your new database. Then in the .env file found in the root directory of your project, please set the values of all variables starting with DB_ accordingly. 2. Installing Web Call Center This project is created as a package to be integrated with a Laravel application, that's why we had to create fresh project first in the previous step. 2.a. Requiring the Package Now to install the project, in the terminal at your project's root directory, please write the following. $ composer require grey-dev-0/web-call-center:@dev 2.b. Publishing Assets Web call center supports customizations to its views and configurations thus, you should publish them to your project in case if you need to customize any of the views (UI) or configurations (settings). $ php artisan vendor:publish --force --provider='GreyZero\\WebCallCenter\\Providers\\AppServiceProvider' 2.c. Populating the Database Well we've created the database for our project, but we haven't started using it yet, so in the same terminal please write the following: $ php artisan queue:table $ php artisan migrate The last couple of commands have published Laravel's background queue jobs tables that will handle processing operations done in background and, it also creates the database tables required by the project to run in general. 3. Integrating Agora The package relies on Agora IO WebRTC services to implement the voice calls feature between customers and agents, the service provides a free plan that's a good starter for this project so, first you'll have to sign up to their service here or, if you already have an account you can directly use it. For detailed steps on how to setup Agora in our project please refer to Agora installation page . 4. Integrating Laravel Websockets Laravel Websockets is a library used internally by this project that enables the server to monitor which customer support agents are currently online within each organization, so that incoming calls can only be assigned to online agents. To set it up please refer to Laravel Websockets installation page . 5. Web Server Configuration At this point our project is running in background but, most likely it's not serving anyone because, we haven't covered the web server configuration for our project so, let's finalize our setup with this last step. Nginx Apache If you don't have nginx configuration file for the project yet, please create one in /etc/nginx/conf.d directory, filename doesn't matter much as long as it ends with .conf extension, in that file whether you've just created it or you're editing an existing one please ensure it matches the following, replacing all <placeholder> values with your corresponding values: server { listen 80; # Disable this on Production server for security listen [::]:80; # Disable this too on Production listen 443 ssl; listen [::]:443 ssl; server_name <your_domain>; ssl_certificate /etc/nginx/ssl/certificate.pem; ssl_certificate_key /etc/nginx/ssl/key.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_tickets off; ssl_stapling off; ssl_stapling_verify off; index index.php; root <aboslute_path_to_project>/public; location / { try_files $uri $uri/ /index.php$is_args$args; } location /app/<app_key_in_env_file> { proxy_pass http://127.0.0.1:6001; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade \"websocket\"; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 30000s; proxy_send_timeout 30000s; proxy_redirect off; proxy_connect_timeout 30000s; } # Replace this with your php-fpm configuration block or correct configuration file. include common/php-fpm.conf; location ~ \\.env$ { deny all; } } Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the nginx configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ nginx -s reload You'll need to add the following VirtualHost block to your default Apache configuration or, edit the one that corresponds with your server's domain name if you're on a server, replacing all <placeholder> values with your corresponding values, the file can be created or edited if exists in /etc/httpd/conf.d directory: <VirtualHost *:80> # Remove this block on Production server for security. ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> <VirtualHost *:443> ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public SSLEngine on SSLCertificateFile /etc/apache2/ssl/certificate.pem SSLCertificateKeyFile /etc/apache2/ssl/key.pem <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the apache configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ systemctl restart httpd If that didn't work due to a command not found error, you can write: $ service httpd restart 6. We're Done. What's Next! If you have followed all the steps above you're having a functional call center web application running but, there are no organizations, agents nor, customers in the system to try out so, you have two options: Connect to the project's database and create them yourself. Or run php artisan db:seed --class TestSeeder . If you run the seeder, a couple of dummy organizations will be created for you in the database including some agents for each and, some customers, by accessing https://<your_domain>/login - replacing <your_domain> with your actual project's domain - then entering the username agent00 or client20 and password test123 you'll be logged in to the corresponding dashboard. You can check the rest of the accounts created in the wcc_users table in the project's database.","title":"Bare Project"},{"location":"getting-started/bare-project/#bare-project","text":"","title":"Bare Project"},{"location":"getting-started/bare-project/#overview","text":"This guide will lead you to install the project as a stand-alone web application, most of the configuration settings will be kept intact and, default web views will be used directly.","title":"Overview"},{"location":"getting-started/bare-project/#1-creating-a-laravel-project","text":"First you'll need a fresh installation of the Laravel framework by going through its official documentation here , or you can follow the following summarized steps.","title":"1. Creating a Laravel project."},{"location":"getting-started/bare-project/#1a-create-project","text":"In terminal at your web root please run the following command: $ composer create-project laravel/laravel <your_project_name> --prefer-dist $ cd <your_project_name> Replacing <your_project_name> with project name of your preference.","title":"1.a. Create project"},{"location":"getting-started/bare-project/#1b-setting-up-the-database","text":"Then you'll have to create the database for the project so, you'll need to login to your database server in terminal. $ mysql -u <username> -p Replacing <username> with your database server's username then, enter the password when prompted and, finally in the open mysql terminal you may write: create database <database_name>; exit; Replacing <database_name> with the name you'd like to give to your new database. Then in the .env file found in the root directory of your project, please set the values of all variables starting with DB_ accordingly.","title":"1.b. Setting up the Database."},{"location":"getting-started/bare-project/#2-installing-web-call-center","text":"This project is created as a package to be integrated with a Laravel application, that's why we had to create fresh project first in the previous step.","title":"2. Installing Web Call Center"},{"location":"getting-started/bare-project/#2a-requiring-the-package","text":"Now to install the project, in the terminal at your project's root directory, please write the following. $ composer require grey-dev-0/web-call-center:@dev","title":"2.a. Requiring the Package"},{"location":"getting-started/bare-project/#2b-publishing-assets","text":"Web call center supports customizations to its views and configurations thus, you should publish them to your project in case if you need to customize any of the views (UI) or configurations (settings). $ php artisan vendor:publish --force --provider='GreyZero\\WebCallCenter\\Providers\\AppServiceProvider'","title":"2.b. Publishing Assets"},{"location":"getting-started/bare-project/#2c-populating-the-database","text":"Well we've created the database for our project, but we haven't started using it yet, so in the same terminal please write the following: $ php artisan queue:table $ php artisan migrate The last couple of commands have published Laravel's background queue jobs tables that will handle processing operations done in background and, it also creates the database tables required by the project to run in general.","title":"2.c. Populating the Database"},{"location":"getting-started/bare-project/#3-integrating-agora","text":"The package relies on Agora IO WebRTC services to implement the voice calls feature between customers and agents, the service provides a free plan that's a good starter for this project so, first you'll have to sign up to their service here or, if you already have an account you can directly use it. For detailed steps on how to setup Agora in our project please refer to Agora installation page .","title":"3. Integrating Agora"},{"location":"getting-started/bare-project/#4-integrating-laravel-websockets","text":"Laravel Websockets is a library used internally by this project that enables the server to monitor which customer support agents are currently online within each organization, so that incoming calls can only be assigned to online agents. To set it up please refer to Laravel Websockets installation page .","title":"4. Integrating Laravel Websockets"},{"location":"getting-started/bare-project/#5-web-server-configuration","text":"At this point our project is running in background but, most likely it's not serving anyone because, we haven't covered the web server configuration for our project so, let's finalize our setup with this last step. Nginx Apache If you don't have nginx configuration file for the project yet, please create one in /etc/nginx/conf.d directory, filename doesn't matter much as long as it ends with .conf extension, in that file whether you've just created it or you're editing an existing one please ensure it matches the following, replacing all <placeholder> values with your corresponding values: server { listen 80; # Disable this on Production server for security listen [::]:80; # Disable this too on Production listen 443 ssl; listen [::]:443 ssl; server_name <your_domain>; ssl_certificate /etc/nginx/ssl/certificate.pem; ssl_certificate_key /etc/nginx/ssl/key.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_tickets off; ssl_stapling off; ssl_stapling_verify off; index index.php; root <aboslute_path_to_project>/public; location / { try_files $uri $uri/ /index.php$is_args$args; } location /app/<app_key_in_env_file> { proxy_pass http://127.0.0.1:6001; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade \"websocket\"; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 30000s; proxy_send_timeout 30000s; proxy_redirect off; proxy_connect_timeout 30000s; } # Replace this with your php-fpm configuration block or correct configuration file. include common/php-fpm.conf; location ~ \\.env$ { deny all; } } Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the nginx configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ nginx -s reload You'll need to add the following VirtualHost block to your default Apache configuration or, edit the one that corresponds with your server's domain name if you're on a server, replacing all <placeholder> values with your corresponding values, the file can be created or edited if exists in /etc/httpd/conf.d directory: <VirtualHost *:80> # Remove this block on Production server for security. ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> <VirtualHost *:443> ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public SSLEngine on SSLCertificateFile /etc/apache2/ssl/certificate.pem SSLCertificateKeyFile /etc/apache2/ssl/key.pem <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the apache configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ systemctl restart httpd If that didn't work due to a command not found error, you can write: $ service httpd restart","title":"5. Web Server Configuration"},{"location":"getting-started/bare-project/#6-were-done-whats-next","text":"If you have followed all the steps above you're having a functional call center web application running but, there are no organizations, agents nor, customers in the system to try out so, you have two options: Connect to the project's database and create them yourself. Or run php artisan db:seed --class TestSeeder . If you run the seeder, a couple of dummy organizations will be created for you in the database including some agents for each and, some customers, by accessing https://<your_domain>/login - replacing <your_domain> with your actual project's domain - then entering the username agent00 or client20 and password test123 you'll be logged in to the corresponding dashboard. You can check the rest of the accounts created in the wcc_users table in the project's database.","title":"6. We're Done. What's Next!"},{"location":"getting-started/integrated-project/","text":"Integrated Project Overview If you already have an existing Laravel project, you can easily integrate Web Call Center into it, you have the option to use all the database tables and models provided by the package or, customize it so that you can pick which of your own models represent any of the following entities: Organization which represents the establishment that has one or more customer service agents. Agent which represents the customer service agent. Customer which represents the customer. So basically a customer would be calling an organization of their choice then, their call will automatically be assigned to the organization 's least occupied agent who's currently online, the incoming calls will be queued to the assigned agents accordingly, so they'd pick up and answer them as soon as possible in FIFO - first in first served - fashion. The Call entity is the only fixed entity that it's not allowed to be customized or replaced at the moment however, it will automatically be associated with the other entities regardless whether you replace any of them with your own models, more on how to do that customization is explained below, anyway please follow the steps stated in this page to avoid any potential errors. 1. Installing Web Call Center This project is created as a package to be integrated with a Laravel application so, let's set it up by following the next steps. 1.a. Requiring the Package In the terminal at your project's root directory, please write the following. $ composer require grey-dev-0/web-call-center:@dev 1.b. Publishing Assets This step is necessary for publishing the configuration files that you'd update to customize the integration of Web Call Center to your Laravel project, besides it will publish Web Call Center's blade views, so that you can customize them to match your application's stying and UI and, finally required frontend assets are also published for UI to work. $ php artisan vendor:publish --force --provider='GreyZero\\WebCallCenter\\Providers\\AppServiceProvider' 1.c Configuring Web Call Center After publishing the assets you'll find the configuration file of Web Call Center located in your default configuration directory i.e. config/web-call-center.php , despite the clarity of comments written before each configuration setting let's have a quick look into the most ambiguous ones. middleware : sets the default middleware to be used by the package and, implicitly sets the default authentication's users provider to the package's User model so, if you plan to authenticate your own users into Web Call Center please change it to web instead. morph_authenticatable : If set to true then the authentication entity must have a polymorphic relationship with Agent and Customer entities, otherwise it means that each Agent and Customer entities are authenticatable models on their own, note that this only to be changed if you set your custom middleware setting and, you'd authenticate agents and customers by their separate entities. customer_model , agent_model and, organization_model are the full model class names - including the namespace - that represent each entity, you may change any of them to the model class existing in your own Laravel application which represents that corresponding entity. organization_foreign_key : The foreign key that relates the Agent entity's table to the Organization entity's table, you'd need to change this accordingly if you customize either or both of Organization and Agent model classes mentioned in the previous point. incremental_primary_key : each table of the main three tables will have an incremental primary key by default, if you'd like to set the primary key manually for any created record of those tables, you can simply set the flag of that table to false , the purpose of setting it to false would be using the primary key as a foreign key that refers to another table or entity in your own Laravel application. 1.d. Database Setup In this step we'll run the database migration command to create the tables required by Web Call Center, provided that you've set the configuration settings that suit your project in the previous step, please note that this step is necessary even if you've designated your own models to all of the customizable models, as the calls table is required regardless and, needs to be created for the call center to function. If you don't have Laravel queues feature enabled in your project, please enable it by setting QUEUE_CONNECTION variable to database in the .env file then, in terminal at your project's root directory you'll need to write: $ php artisan queue:table What if queues are already enabled but on a connection other than database e.g. redis ? Skip the queues related part in this case but, you'll still need to proceed to the migrate command mentioned afterwards. Then finally you'll need to run the following terminal command to run all required database migrations. $ php artisan migrate 2. Custom Eloquent Models If you have set your own model class for any of the major three entities Organization , Agent or, Customer please check the sections that correspond to your customized entities in this step. Also if you have set custom middleware value, please check the User Model section as well. 2.a. Organization Model If you have changed organization_model configuration setting in the config/web-call-center.php file to an existing model in your project that represents the Organization entity e.g. \\App\\Models\\SomeAgency::class then, you'll need to use the HasAgents trait in that class so, the class would look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\HasAgents; use Illuminate\\Database\\Eloquent\\Model; class SomeAgency extends Model{ use HasAgents; // ... } 2.b. Agent Model If you have changed agent_model configuration setting in the config/web-call-center.php file to an existing model in your project that represents the Agent entity e.g. \\App\\Models\\SomeAgent::class then, you'll need to use the ReceivesCalls trait in that class so, the class would look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\ReceivesCalls; use Illuminate\\Database\\Eloquent\\Model; class SomeAgent extends Model{ use ReceivesCalls; // ... } 2.c. Customer Model If you have changed customer_model configuration setting in the config/web-call-center.php file to an existing model in your project that represents the Customer entity e.g. \\App\\Models\\SomeCustomer::class then, you'll need to use the MakesCalls trait in that class so, the class would look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\MakesCalls; use Illuminate\\Database\\Eloquent\\Model; class SomeCustomer extends Model{ use MakesCalls; // ... } 2.d. User Model If you have changed the middleware configuration setting in the config/web-call-center.php file to web or any other middleware than the preset default, you'll need to use the UsesCallCenter trait in your authenticatable model(s), in case if you have one authentication model i.e. morph_authenticatable is set to true then, you'll use that trait in that model class, otherwise you'll need to use that trait with each authenticatable model; the one that represents the Agent and the one that represents the Customer . Single Authentication Model Multiple Authentication Models morph_authenticatable is true in this case i.e. you're authenticating your users using the default User model provided by Laravel which is modified by you or, you might be using another model of your own that relates to Agent and Customer via a polymorphic relationship. namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\UsesCallCenter; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Illuminate\\Notifications\\Notifiable; use Laravel\\Sanctum\\HasApiTokens; class User extends Authenticatable{ use HasApiTokens, HasFactory, Notifiable, UsesCallCenter; // ... } morph_authenticatable is false in this case i.e. you're authenticating your users using several models, so we need to define which of them are going to use Web Call Center besides, which of them will represent the Agent and which will represent the Customer so, the model that represents the Agent in your project should look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\ReceivesCalls; use GreyZero\\WebCallCenter\\Traits\\UsesCallCenter; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Laravel\\Sanctum\\HasApiTokens; class SomeAgent extends Authenticatable{ use HasApiTokens, HasFactory, ReceivesCalls, UsesCallCenter; // ... } And the model that represents the Customer in your project should look like this: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\MakesCalls; use GreyZero\\WebCallCenter\\Traits\\UsesCallCenter; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Illuminate\\Notifications\\Notifiable; use Laravel\\Sanctum\\HasApiTokens; class SomeCustomer extends Authenticatable{ use HasApiTokens, HasFactory, MakesCalls, Notifiable, UsesCallCenter; // ... } 3. Integrating Agora The package relies on Agora IO WebRTC services to implement the voice calls feature between customers and agents, the service provides a free plan that's a good starter for this project so, first you'll have to sign up to their service here or, if you already have an account you can directly use it. For detailed steps on how to setup Agora in our project please refer to Agora installation page . 4. Integrating Laravel Websockets Laravel Websockets is a library used internally by this project that enables the server to monitor which customer support agents are currently online within each organization, so that incoming calls can only be assigned to online agents. To set it up please refer to Laravel Websockets installation page . 5. Web Server Configuration As seen in the previous step this project relies on Websockets to manage online customer service agents so, you'll need to ensure that websocket related settings are properly set in your web server configuration file. Nginx Apache If you don't have nginx configuration file for the project yet, please create one in /etc/nginx/conf.d directory, filename doesn't matter much as long as it ends with .conf extension, in that file whether you've just created it or you're editing an existing one please ensure it matches the following, replacing all <placeholder> values with your corresponding values: server { listen 80; # Disable this on Production server for security listen [::]:80; # Disable this too on Production listen 443 ssl; listen [::]:443 ssl; server_name <your_domain>; ssl_certificate /etc/nginx/ssl/certificate.pem; ssl_certificate_key /etc/nginx/ssl/key.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_tickets off; ssl_stapling off; ssl_stapling_verify off; index index.php; root <aboslute_path_to_project>/public; location / { try_files $uri $uri/ /index.php$is_args$args; } location /app/<app_key_in_env_file> { proxy_pass http://127.0.0.1:6001; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade \"websocket\"; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 30000s; proxy_send_timeout 30000s; proxy_redirect off; proxy_connect_timeout 30000s; } # Replace this with your php-fpm configuration block or correct configuration file. include common/php-fpm.conf; location ~ \\.env$ { deny all; } } Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the nginx configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ nginx -s reload You'll need to add the following VirtualHost block to your default Apache configuration or, edit the one that corresponds with your server's domain name if you're on a server, replacing all <placeholder> values with your corresponding values, the file can be created or edited if exists in /etc/httpd/conf.d directory: <VirtualHost *:80> # Remove this block on Production server for security. ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> <VirtualHost *:443> ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public SSLEngine on SSLCertificateFile /etc/apache2/ssl/certificate.pem SSLCertificateKeyFile /etc/apache2/ssl/key.pem <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the apache configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ systemctl restart httpd If that didn't work due to a command not found error, you can write: $ service httpd restart 6. We're Done. What's Next! Based on your prefix setting in the config/web-call-center.php config file, if it's not set null then you can access the customer and the agent dashboards on https://<your_domain>/<prefix>/customer and, https://<your_domain>/<prefix>/agent respectively, replacing <your_domain > with the domain name that's configured to access your project and, <prefix> with the value of the prefix setting in the mentioned configuration file. If it's set to null simply omit the <prefix>/ part from the said URLs. Notice Please note that authentication middleware will be applied so, you'll be prompted to login using a customer or an agent account before you can proceed to the requested dashboard.","title":"Integrated Project"},{"location":"getting-started/integrated-project/#integrated-project","text":"","title":"Integrated Project"},{"location":"getting-started/integrated-project/#overview","text":"If you already have an existing Laravel project, you can easily integrate Web Call Center into it, you have the option to use all the database tables and models provided by the package or, customize it so that you can pick which of your own models represent any of the following entities: Organization which represents the establishment that has one or more customer service agents. Agent which represents the customer service agent. Customer which represents the customer. So basically a customer would be calling an organization of their choice then, their call will automatically be assigned to the organization 's least occupied agent who's currently online, the incoming calls will be queued to the assigned agents accordingly, so they'd pick up and answer them as soon as possible in FIFO - first in first served - fashion. The Call entity is the only fixed entity that it's not allowed to be customized or replaced at the moment however, it will automatically be associated with the other entities regardless whether you replace any of them with your own models, more on how to do that customization is explained below, anyway please follow the steps stated in this page to avoid any potential errors.","title":"Overview"},{"location":"getting-started/integrated-project/#1-installing-web-call-center","text":"This project is created as a package to be integrated with a Laravel application so, let's set it up by following the next steps.","title":"1. Installing Web Call Center"},{"location":"getting-started/integrated-project/#1a-requiring-the-package","text":"In the terminal at your project's root directory, please write the following. $ composer require grey-dev-0/web-call-center:@dev","title":"1.a. Requiring the Package"},{"location":"getting-started/integrated-project/#1b-publishing-assets","text":"This step is necessary for publishing the configuration files that you'd update to customize the integration of Web Call Center to your Laravel project, besides it will publish Web Call Center's blade views, so that you can customize them to match your application's stying and UI and, finally required frontend assets are also published for UI to work. $ php artisan vendor:publish --force --provider='GreyZero\\WebCallCenter\\Providers\\AppServiceProvider'","title":"1.b. Publishing Assets"},{"location":"getting-started/integrated-project/#1c-configuring-web-call-center","text":"After publishing the assets you'll find the configuration file of Web Call Center located in your default configuration directory i.e. config/web-call-center.php , despite the clarity of comments written before each configuration setting let's have a quick look into the most ambiguous ones. middleware : sets the default middleware to be used by the package and, implicitly sets the default authentication's users provider to the package's User model so, if you plan to authenticate your own users into Web Call Center please change it to web instead. morph_authenticatable : If set to true then the authentication entity must have a polymorphic relationship with Agent and Customer entities, otherwise it means that each Agent and Customer entities are authenticatable models on their own, note that this only to be changed if you set your custom middleware setting and, you'd authenticate agents and customers by their separate entities. customer_model , agent_model and, organization_model are the full model class names - including the namespace - that represent each entity, you may change any of them to the model class existing in your own Laravel application which represents that corresponding entity. organization_foreign_key : The foreign key that relates the Agent entity's table to the Organization entity's table, you'd need to change this accordingly if you customize either or both of Organization and Agent model classes mentioned in the previous point. incremental_primary_key : each table of the main three tables will have an incremental primary key by default, if you'd like to set the primary key manually for any created record of those tables, you can simply set the flag of that table to false , the purpose of setting it to false would be using the primary key as a foreign key that refers to another table or entity in your own Laravel application.","title":"1.c Configuring Web Call Center"},{"location":"getting-started/integrated-project/#1d-database-setup","text":"In this step we'll run the database migration command to create the tables required by Web Call Center, provided that you've set the configuration settings that suit your project in the previous step, please note that this step is necessary even if you've designated your own models to all of the customizable models, as the calls table is required regardless and, needs to be created for the call center to function. If you don't have Laravel queues feature enabled in your project, please enable it by setting QUEUE_CONNECTION variable to database in the .env file then, in terminal at your project's root directory you'll need to write: $ php artisan queue:table What if queues are already enabled but on a connection other than database e.g. redis ? Skip the queues related part in this case but, you'll still need to proceed to the migrate command mentioned afterwards. Then finally you'll need to run the following terminal command to run all required database migrations. $ php artisan migrate","title":"1.d. Database Setup"},{"location":"getting-started/integrated-project/#2-custom-eloquent-models","text":"If you have set your own model class for any of the major three entities Organization , Agent or, Customer please check the sections that correspond to your customized entities in this step. Also if you have set custom middleware value, please check the User Model section as well.","title":"2. Custom Eloquent Models"},{"location":"getting-started/integrated-project/#2a-organization-model","text":"If you have changed organization_model configuration setting in the config/web-call-center.php file to an existing model in your project that represents the Organization entity e.g. \\App\\Models\\SomeAgency::class then, you'll need to use the HasAgents trait in that class so, the class would look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\HasAgents; use Illuminate\\Database\\Eloquent\\Model; class SomeAgency extends Model{ use HasAgents; // ... }","title":"2.a. Organization Model"},{"location":"getting-started/integrated-project/#2b-agent-model","text":"If you have changed agent_model configuration setting in the config/web-call-center.php file to an existing model in your project that represents the Agent entity e.g. \\App\\Models\\SomeAgent::class then, you'll need to use the ReceivesCalls trait in that class so, the class would look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\ReceivesCalls; use Illuminate\\Database\\Eloquent\\Model; class SomeAgent extends Model{ use ReceivesCalls; // ... }","title":"2.b. Agent Model"},{"location":"getting-started/integrated-project/#2c-customer-model","text":"If you have changed customer_model configuration setting in the config/web-call-center.php file to an existing model in your project that represents the Customer entity e.g. \\App\\Models\\SomeCustomer::class then, you'll need to use the MakesCalls trait in that class so, the class would look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\MakesCalls; use Illuminate\\Database\\Eloquent\\Model; class SomeCustomer extends Model{ use MakesCalls; // ... }","title":"2.c. Customer Model"},{"location":"getting-started/integrated-project/#2d-user-model","text":"If you have changed the middleware configuration setting in the config/web-call-center.php file to web or any other middleware than the preset default, you'll need to use the UsesCallCenter trait in your authenticatable model(s), in case if you have one authentication model i.e. morph_authenticatable is set to true then, you'll use that trait in that model class, otherwise you'll need to use that trait with each authenticatable model; the one that represents the Agent and the one that represents the Customer . Single Authentication Model Multiple Authentication Models morph_authenticatable is true in this case i.e. you're authenticating your users using the default User model provided by Laravel which is modified by you or, you might be using another model of your own that relates to Agent and Customer via a polymorphic relationship. namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\UsesCallCenter; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Illuminate\\Notifications\\Notifiable; use Laravel\\Sanctum\\HasApiTokens; class User extends Authenticatable{ use HasApiTokens, HasFactory, Notifiable, UsesCallCenter; // ... } morph_authenticatable is false in this case i.e. you're authenticating your users using several models, so we need to define which of them are going to use Web Call Center besides, which of them will represent the Agent and which will represent the Customer so, the model that represents the Agent in your project should look like the following: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\ReceivesCalls; use GreyZero\\WebCallCenter\\Traits\\UsesCallCenter; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Laravel\\Sanctum\\HasApiTokens; class SomeAgent extends Authenticatable{ use HasApiTokens, HasFactory, ReceivesCalls, UsesCallCenter; // ... } And the model that represents the Customer in your project should look like this: namespace App\\Models; use GreyZero\\WebCallCenter\\Traits\\MakesCalls; use GreyZero\\WebCallCenter\\Traits\\UsesCallCenter; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Illuminate\\Notifications\\Notifiable; use Laravel\\Sanctum\\HasApiTokens; class SomeCustomer extends Authenticatable{ use HasApiTokens, HasFactory, MakesCalls, Notifiable, UsesCallCenter; // ... }","title":"2.d. User Model"},{"location":"getting-started/integrated-project/#3-integrating-agora","text":"The package relies on Agora IO WebRTC services to implement the voice calls feature between customers and agents, the service provides a free plan that's a good starter for this project so, first you'll have to sign up to their service here or, if you already have an account you can directly use it. For detailed steps on how to setup Agora in our project please refer to Agora installation page .","title":"3. Integrating Agora"},{"location":"getting-started/integrated-project/#4-integrating-laravel-websockets","text":"Laravel Websockets is a library used internally by this project that enables the server to monitor which customer support agents are currently online within each organization, so that incoming calls can only be assigned to online agents. To set it up please refer to Laravel Websockets installation page .","title":"4. Integrating Laravel Websockets"},{"location":"getting-started/integrated-project/#5-web-server-configuration","text":"As seen in the previous step this project relies on Websockets to manage online customer service agents so, you'll need to ensure that websocket related settings are properly set in your web server configuration file. Nginx Apache If you don't have nginx configuration file for the project yet, please create one in /etc/nginx/conf.d directory, filename doesn't matter much as long as it ends with .conf extension, in that file whether you've just created it or you're editing an existing one please ensure it matches the following, replacing all <placeholder> values with your corresponding values: server { listen 80; # Disable this on Production server for security listen [::]:80; # Disable this too on Production listen 443 ssl; listen [::]:443 ssl; server_name <your_domain>; ssl_certificate /etc/nginx/ssl/certificate.pem; ssl_certificate_key /etc/nginx/ssl/key.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_tickets off; ssl_stapling off; ssl_stapling_verify off; index index.php; root <aboslute_path_to_project>/public; location / { try_files $uri $uri/ /index.php$is_args$args; } location /app/<app_key_in_env_file> { proxy_pass http://127.0.0.1:6001; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade \"websocket\"; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 30000s; proxy_send_timeout 30000s; proxy_redirect off; proxy_connect_timeout 30000s; } # Replace this with your php-fpm configuration block or correct configuration file. include common/php-fpm.conf; location ~ \\.env$ { deny all; } } Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the nginx configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ nginx -s reload You'll need to add the following VirtualHost block to your default Apache configuration or, edit the one that corresponds with your server's domain name if you're on a server, replacing all <placeholder> values with your corresponding values, the file can be created or edited if exists in /etc/httpd/conf.d directory: <VirtualHost *:80> # Remove this block on Production server for security. ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> <VirtualHost *:443> ServerName <your_domain_name> DocumentRoot <aboslute_path_to_project>/public SSLEngine on SSLCertificateFile /etc/apache2/ssl/certificate.pem SSLCertificateKeyFile /etc/apache2/ssl/key.pem <Location \"/app/<app_key_in_env_file>\"> ProxyRequests on RequestHeader set X-Forwarded-Proto \"http\" ProxyPass / https://127.0.0.1:6001/ ProxyPassReverse / https://127.0.0.1:6001/ RewriteEngine on RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:6001%{REQUEST_URI} [P] </Location> </VirtualHost> Notice If you have changed the default websocket port with LARAVEL_WEBSOCKETS_PORT variable in the .env file, please replace the port 6001 in the apache configuration above with the one you specified in the .env file accordingly. IMPORTANT After saving the file you'll need to run the following command in terminal to use the new configuration. $ systemctl restart httpd If that didn't work due to a command not found error, you can write: $ service httpd restart","title":"5. Web Server Configuration"},{"location":"getting-started/integrated-project/#6-were-done-whats-next","text":"Based on your prefix setting in the config/web-call-center.php config file, if it's not set null then you can access the customer and the agent dashboards on https://<your_domain>/<prefix>/customer and, https://<your_domain>/<prefix>/agent respectively, replacing <your_domain > with the domain name that's configured to access your project and, <prefix> with the value of the prefix setting in the mentioned configuration file. If it's set to null simply omit the <prefix>/ part from the said URLs. Notice Please note that authentication middleware will be applied so, you'll be prompted to login using a customer or an agent account before you can proceed to the requested dashboard.","title":"6. We're Done. What's Next!"},{"location":"third-parties/agora/","text":"Agora Overview Agora is a WebRTC service that provides Video / Voice / Text chat implementation that can be integrated and added to any application, it's used by this project to enable customers to contact customer support / service agents on web voice calls, which can be initiated from a web browser or a mobile application that uses Agora SDK. Enabling Agora Integration To start using this project it's required that you use your Agora account's integration credentials so, to achieve this please follow the upcoming steps: Signup on Agora here , it's free and, no credit / debit card entry required. Create your first Agora project on their dashboard by following their on-boarding wizard. In Agora's main dashboard page, click the \"Config\" button found within your project's section. Click the copy icon in the \"App ID\" field then paste it to the end of your Laravel project's .env file with the key AGORA_APP_ID so, the line added is AGORA_APP_ID=<your_app_id> replacing <your_app_id> with the code you've copied. Click the copy icon in the \"App Certificate\" field then paste it to the end of the .env file like the previous one but with the key AGORA_CERTIFICATE . Continue the Setup. That's it, you've successfully integrated Agora service to the project, you'll need to follow the remaining steps to finalize the setup of the project so you can now: Continue Bare Project setup . Continue Integrated Project setup .","title":"Agora"},{"location":"third-parties/agora/#agora","text":"","title":"Agora"},{"location":"third-parties/agora/#overview","text":"Agora is a WebRTC service that provides Video / Voice / Text chat implementation that can be integrated and added to any application, it's used by this project to enable customers to contact customer support / service agents on web voice calls, which can be initiated from a web browser or a mobile application that uses Agora SDK.","title":"Overview"},{"location":"third-parties/agora/#enabling-agora-integration","text":"To start using this project it's required that you use your Agora account's integration credentials so, to achieve this please follow the upcoming steps: Signup on Agora here , it's free and, no credit / debit card entry required. Create your first Agora project on their dashboard by following their on-boarding wizard. In Agora's main dashboard page, click the \"Config\" button found within your project's section. Click the copy icon in the \"App ID\" field then paste it to the end of your Laravel project's .env file with the key AGORA_APP_ID so, the line added is AGORA_APP_ID=<your_app_id> replacing <your_app_id> with the code you've copied. Click the copy icon in the \"App Certificate\" field then paste it to the end of the .env file like the previous one but with the key AGORA_CERTIFICATE .","title":"Enabling Agora Integration"},{"location":"third-parties/agora/#continue-the-setup","text":"That's it, you've successfully integrated Agora service to the project, you'll need to follow the remaining steps to finalize the setup of the project so you can now: Continue Bare Project setup . Continue Integrated Project setup .","title":"Continue the Setup."},{"location":"third-parties/websocket/","text":"Laravel Websockets Overview In order for this project to properly manage and assign incoming calls to online least occupied customer agents, it utilizes Laravel Websockets library to enable the server realtime communication with customer agents, thus recognizing which agents are online within each organization besides, notifying them about their assigned calls once they come in. Laravel Websockets Integration 1. Setting Required .env variables. Please set ensure the existence and setting of the following environment variables in your project's .env file. PUSHER_APP_ID=<app_id> PUSHER_APP_KEY=<app_key> PUSHER_APP_SECRET=<app_secret> PUSHER_APP_CLUSTER=<app_cluster> Replacing all values with any string of your preference however, special characters should be avoided to prevent any potential errors or malfunctions. 2. Setting up Broadcasting configuration In your project's config/broadcasting.php file, please replace the pusher entry with following block: 'pusher' => [ 'driver' => 'pusher', 'key' => env('PUSHER_APP_KEY'), 'secret' => env('PUSHER_APP_SECRET'), 'app_id' => env('PUSHER_APP_ID'), 'options' => [ 'cluster' => env('PUSHER_APP_CLUSTER'), 'encrypted' => true, 'host' => '127.0.0.1', 'port' => env('LARAVEL_WEBSOCKETS_PORT', 6001), 'scheme' => 'http' ], ] This configuration is necessary to enable handled HTTP requests query the websocket server about current customer agents status when required. 3. Starting up Required Background Services For Laravel Websockets and Notifications System to function a couple of background services must be launched on the server hosting this project or, on your pc if your trying this project locally. First make sure that the QUEUE_CONNECTION key in your project's .env file is set to database or any value other than sync if you're not using the database for handling Laravel's background jobs, then in terminal at your project's directory please write the following: $ nohup php artisan queue:work > storage/logs/queues.log & $ nohup php artisan websockets:serve > storage/logs/websocket.log & These couple of lines will run the required services mentioned and log their output to the files specified after the > operator so, in case of problems you can always check those files for debugging. nohup command is used here to ensure that the services keep running even after you close the terminal so, these services will keep running until you either restart the server - or pc - or, an error occurs in one of them. Continue the Setup. That's it, you've successfully setup Laravel Websockets for the project, you'll need to follow the remaining steps to finalize the setup of the project so you can now: Continue Bare Project setup . Continue Integrated Project setup .","title":"Laravel Websockets"},{"location":"third-parties/websocket/#laravel-websockets","text":"","title":"Laravel Websockets"},{"location":"third-parties/websocket/#overview","text":"In order for this project to properly manage and assign incoming calls to online least occupied customer agents, it utilizes Laravel Websockets library to enable the server realtime communication with customer agents, thus recognizing which agents are online within each organization besides, notifying them about their assigned calls once they come in.","title":"Overview"},{"location":"third-parties/websocket/#laravel-websockets-integration","text":"","title":"Laravel Websockets Integration"},{"location":"third-parties/websocket/#1-setting-required-env-variables","text":"Please set ensure the existence and setting of the following environment variables in your project's .env file. PUSHER_APP_ID=<app_id> PUSHER_APP_KEY=<app_key> PUSHER_APP_SECRET=<app_secret> PUSHER_APP_CLUSTER=<app_cluster> Replacing all values with any string of your preference however, special characters should be avoided to prevent any potential errors or malfunctions.","title":"1. Setting Required .env variables."},{"location":"third-parties/websocket/#2-setting-up-broadcasting-configuration","text":"In your project's config/broadcasting.php file, please replace the pusher entry with following block: 'pusher' => [ 'driver' => 'pusher', 'key' => env('PUSHER_APP_KEY'), 'secret' => env('PUSHER_APP_SECRET'), 'app_id' => env('PUSHER_APP_ID'), 'options' => [ 'cluster' => env('PUSHER_APP_CLUSTER'), 'encrypted' => true, 'host' => '127.0.0.1', 'port' => env('LARAVEL_WEBSOCKETS_PORT', 6001), 'scheme' => 'http' ], ] This configuration is necessary to enable handled HTTP requests query the websocket server about current customer agents status when required.","title":"2. Setting up Broadcasting configuration"},{"location":"third-parties/websocket/#3-starting-up-required-background-services","text":"For Laravel Websockets and Notifications System to function a couple of background services must be launched on the server hosting this project or, on your pc if your trying this project locally. First make sure that the QUEUE_CONNECTION key in your project's .env file is set to database or any value other than sync if you're not using the database for handling Laravel's background jobs, then in terminal at your project's directory please write the following: $ nohup php artisan queue:work > storage/logs/queues.log & $ nohup php artisan websockets:serve > storage/logs/websocket.log & These couple of lines will run the required services mentioned and log their output to the files specified after the > operator so, in case of problems you can always check those files for debugging. nohup command is used here to ensure that the services keep running even after you close the terminal so, these services will keep running until you either restart the server - or pc - or, an error occurs in one of them.","title":"3. Starting up Required Background Services"},{"location":"third-parties/websocket/#continue-the-setup","text":"That's it, you've successfully setup Laravel Websockets for the project, you'll need to follow the remaining steps to finalize the setup of the project so you can now: Continue Bare Project setup . Continue Integrated Project setup .","title":"Continue the Setup."}]}